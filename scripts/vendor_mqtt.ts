// Deno script to vendor mqtt.js browser ESM bundle locally for offline use.
// Usage:
//   deno run -A scripts/vendor_mqtt.ts [version]
// Example:
//   deno run -A scripts/vendor_mqtt.ts 5
// Outputs:
//   web/vendor/mqtt/mqtt.bundle.mjs (ES module bundle compatible with browsers)
//   web/vendor/mqtt/README.txt
//   web/vendor/mqtt/LICENSE-mqtt.txt (MIT)

const VERSION = Deno.args[0] || "5"; // mqtt@5
const OUT_DIR = new URL("../web/vendor/mqtt/", import.meta.url);
const OUT_FILE = new URL("mqtt.bundle.mjs", OUT_DIR);

const CANDIDATES = [
  // esm.sh modern ESM bundle; exposes default export with .connect
  `https://esm.sh/mqtt@${VERSION}?bundle`,
  // Skypack (legacy) kept as a last-resort option
  `https://cdn.skypack.dev/mqtt@${VERSION}`,
];

async function ensureDir(url: URL) {
  await Deno.mkdir(url, { recursive: true });
}

async function download(url: string): Promise<string> {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`Failed to fetch ${url}: ${res.status} ${res.statusText}`);
  }
  return await res.text();
}

async function writeText(url: URL, text: string) {
  await Deno.writeTextFile(url, text);
}

async function tryFetchBundle(): Promise<{ code: string; from: string }> {
  for (const u of CANDIDATES) {
    try {
      console.log(`Trying MQTT bundle: ${u}`);
      const code = await download(u);
      // Basic sanity: ensure the code looks like an ES module
      if (
        !/export\s+\{|export\s+default|Object\.defineProperty\(exports,\s*"__esModule"/
          .test(code)
      ) {
        console.warn("Fetched code may not be an ESM bundle; keeping anyway.");
      }
      return { code, from: u };
    } catch (e) {
      console.warn(`Failed: ${u} â†’ ${e.message}`);
    }
  }
  throw new Error("All MQTT bundle sources failed");
}

async function fetchLicense(): Promise<string> {
  const LICENSE_CANDIDATES = [
    // Directly from the mqtt.js repo
    "https://raw.githubusercontent.com/mqttjs/MQTT.js/master/LICENSE.md",
    "https://raw.githubusercontent.com/mqttjs/MQTT.js/main/LICENSE.md",
    // npm registry mirror
    `https://unpkg.com/mqtt@${VERSION}/LICENSE`,
  ];
  for (const url of LICENSE_CANDIDATES) {
    try {
      const text = await download(url);
      return text;
    } catch {
      // try next
    }
  }
  return "MIT License (see MQTT.js repository)";
}

async function main() {
  console.log(`Vendoring mqtt@${VERSION} to web/vendor/mqtt...`);
  await ensureDir(OUT_DIR);
  const { code, from } = await tryFetchBundle();

  // Write bundle
  await writeText(OUT_FILE, code);
  console.log("Wrote:", new URL("./", OUT_DIR).pathname + "mqtt.bundle.mjs");

  // Write README
  const readme = `mqtt.js browser ESM bundle (vendored)\n\n` +
    `Source: ${from}\n` +
    `Version requested: ${VERSION}\n\n` +
    `This file is auto-generated by scripts/vendor_mqtt.ts.\n` +
    `In the app, it is loaded dynamically at runtime from /web/vendor/mqtt/mqtt.bundle.mjs,\n` +
    `with an automatic fallback to the CDN if the local file is missing.\n`;
  await writeText(new URL("README.txt", OUT_DIR), readme);

  // Write LICENSE
  const licenseText = await fetchLicense();
  await writeText(new URL("LICENSE-mqtt.txt", OUT_DIR), licenseText);

  console.log("Done. MQTT vendored for offline use.");
}

if (import.meta.main) {
  main().catch((err) => {
    console.error(err);
    Deno.exit(1);
  });
}
